================================================================================
HEALTHCARE ANALYTICS LAB - PART 2: QUERY PERFORMANCE ANALYSIS
================================================================================

================================================================================
QUESTION 1: Monthly Encounters by Specialty
================================================================================
What we need: For each month and specialty, show total encounters and unique 
patients by encounter type.

SQL Query:
----------
SELECT 
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS month,
    s.specialty_name,
    e.encounter_type,
    COUNT(*) AS total_encounters,
    COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY 
    DATE_FORMAT(e.encounter_date, '%Y-%m'),
    s.specialty_name,
    e.encounter_type
ORDER BY month, s.specialty_name, e.encounter_type;

Schema Analysis:
----------------
Tables joined: encounters, providers, specialties
Number of joins: 2

Performance:
------------
Execution time: 0.397 seconds (Query ID 118)
Estimated rows scanned: ~50,000 encounters × 200 providers × 10 specialties

To measure execution time, run:
SET profiling = 1;
[run the query above]
SHOW PROFILES;

Or use EXPLAIN:
EXPLAIN SELECT ... [the query above]

Bottleneck Identified:
----------------------
- JOIN chain: encounters → providers → specialties (2 JOINs)
- GROUP BY on multiple columns including date function
- No direct relationship between encounters and specialties
- DATE_FORMAT function prevents index usage on encounter_date


================================================================================
QUESTION 2: Top Diagnosis-Procedure Pairs
================================================================================
What we need: What are the most common diagnosis-procedure combinations? 
Show the ICD code, procedure code, and encounter count.

SQL Query:
----------
SELECT 
    d.icd10_code,
    d.icd10_description,
    pr.cpt_code,
    pr.cpt_description,
    COUNT(DISTINCT e.encounter_id) AS encounter_count
FROM encounters e
JOIN encounter_diagnoses ed ON e.encounter_id = ed.encounter_id
JOIN diagnoses d ON ed.diagnosis_id = d.diagnosis_id
JOIN encounter_procedures ep ON e.encounter_id = ep.encounter_id
JOIN procedures pr ON ep.procedure_id = pr.procedure_id
GROUP BY 
    d.icd10_code,
    d.icd10_description,
    pr.cpt_code,
    pr.cpt_description
ORDER BY encounter_count DESC
LIMIT 10;

Schema Analysis:
----------------
Tables joined: encounters, encounter_diagnoses, diagnoses, encounter_procedures, procedures
Number of joins: 4

Performance:
------------
Execution time: 2.999 seconds (Query ID 9) - ROW EXPLOSION!
Estimated rows scanned: ~125K diagnoses × ~100K procedures = row explosion

Bottleneck Identified:
----------------------
- TWO junction tables (encounter_diagnoses, encounter_procedures) 
- Cartesian product effect: Each encounter with N diagnoses and M procedures 
  creates N × M rows before aggregation
- Row explosion problem: Small tables can generate massive intermediate results
- Heavy GROUP BY aggregation required after the explosion


================================================================================
QUESTION 3: 30-Day Readmission Rate
================================================================================
What we need: Which specialty has the highest readmission rate? 
(Definition: inpatient discharge, then return within 30 days)

SQL Query:
----------
SELECT 
    s.specialty_name,
    COUNT(DISTINCT e1.encounter_id) AS total_inpatient_encounters,
    COUNT(DISTINCT e2.encounter_id) AS readmissions,
    ROUND(
        COUNT(DISTINCT e2.encounter_id) * 100.0 / 
        NULLIF(COUNT(DISTINCT e1.encounter_id), 0), 
        2
    ) AS readmission_rate_percent
FROM encounters e1
JOIN providers p ON e1.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
LEFT JOIN encounters e2 ON e1.patient_id = e2.patient_id
    AND e2.encounter_type = 'Inpatient'
    AND e2.encounter_date > e1.discharge_date
    AND e2.encounter_date <= DATE_ADD(e1.discharge_date, INTERVAL 30 DAY)
    AND e2.encounter_id != e1.encounter_id
WHERE e1.encounter_type = 'Inpatient'
GROUP BY s.specialty_name
ORDER BY readmission_rate_percent DESC;

Schema Analysis:
----------------
Tables joined: encounters (self-join), providers, specialties
Number of joins: 3 (including self-join)

Performance:
------------
Execution time: 0.393 seconds (Query ID 126)
Estimated rows scanned: ~50,000 × 50,000 (self-join worst case)

Bottleneck Identified:
----------------------
- SELF-JOIN on encounters table (expensive for large tables)
- Date range comparison in JOIN condition (non-equi join)
- Multiple date calculations: DATE_ADD, comparison operators
- No index support for date range comparisons in JOIN
- Complexity: O(n²) in worst case for self-join


================================================================================
QUESTION 4: Revenue by Specialty & Month
================================================================================
What we need: Total allowed amounts by specialty and month. 
Which specialties generate most revenue?

SQL Query:
----------
SELECT 
    DATE_FORMAT(b.claim_date, '%Y-%m') AS month,
    s.specialty_name,
    SUM(b.allowed_amount) AS total_revenue,
    COUNT(*) AS claim_count,
    ROUND(AVG(b.allowed_amount), 2) AS avg_revenue_per_claim
FROM billing b
JOIN encounters e ON b.encounter_id = e.encounter_id
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY 
    DATE_FORMAT(b.claim_date, '%Y-%m'),
    s.specialty_name
ORDER BY month, total_revenue DESC;

Schema Analysis:
----------------
Tables joined: billing, encounters, providers, specialties
Number of joins: 3

Performance:
------------
Execution time: 0.446 seconds (Query ID 101)
Estimated rows scanned: ~50,000 billing × 50,000 encounters × 200 providers

Bottleneck Identified:
----------------------
- Long JOIN chain: billing → encounters → providers → specialties
- No direct link between billing and specialty (requires 3 hops)
- DATE_FORMAT function prevents index usage
- Aggregation (SUM, AVG) after joining multiple tables
- Revenue data scattered across multiple relationships


================================================================================
SUMMARY OF PERFORMANCE ISSUES IN OLTP SCHEMA
================================================================================

| Query | Tables Joined | Main Bottleneck                          |
|-------|---------------|------------------------------------------|
| Q1    | 3             | JOIN chain + GROUP BY + date function    |
| Q2    | 5             | Two junction tables → row explosion      |
| Q3    | 3 (self-join) | Self-join + date range comparison        |
| Q4    | 4             | Long JOIN chain + aggregation            |

Common Problems:
----------------
1. Multiple JOINs required to answer simple business questions
2. No pre-aggregated metrics (must calculate SUM, COUNT at query time)
3. Indirect relationships (billing → specialty requires 3 JOINs)
4. Junction tables cause row multiplication
5. Date functions prevent index optimization


================================================================================
HOW TO RUN THESE QUERIES IN MYSQL
================================================================================

1. Connect to your MySQL database:
   mysql -u root -p healthcare_db

2. Enable profiling:
   SET profiling = 1;

3. Run each query and note the results

4. Check execution time:
   SHOW PROFILES;

5. Analyze query plan:
   EXPLAIN [query];
   or
   EXPLAIN ANALYZE [query];  -- MySQL 8.0.18+

6. Fill in the execution times and row counts above


================================================================================
