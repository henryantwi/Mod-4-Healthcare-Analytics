================================================================================
HEALTHCARE ANALYTICS LAB - PART 3.4: ETL DESIGN
================================================================================

zThis document outlines how to move data from OLTP (operational database) to 
OLAP (star schema) for analytics. We use INCREMENTAL LOADING (only new/changed
records) and SCD TYPE 2 (track history for key dimensions).


================================================================================
1. HOW WE TRACK CHANGES (Incremental Loading)
================================================================================

PROBLEM: Re-loading ALL data every day is slow and wasteful.

SOLUTION: Track when we last loaded data, then only load new/changed records.

1.1 Tracking Table (etl_metadata)
---------------------------------
```sql
CREATE TABLE etl_metadata (
    table_name VARCHAR(50) PRIMARY KEY,
    last_load_timestamp DATETIME,
    records_loaded INT
);
```

1.2 How It Works
----------------
First run:  Load ALL data, save timestamp "2026-01-20 02:00:00"
Second run: Read last timestamp, load only records WHERE updated_at >= that time
Third run:  Same pattern - always load only what changed since last run

1.3 OLTP Audit Columns
----------------------
OLTP tables need these columns to track changes:
- created_at DATETIME DEFAULT NOW()
- updated_at DATETIME DEFAULT NOW() ON UPDATE NOW()

These auto-update when records change, so ETL knows what's new.


================================================================================
2. SLOWLY CHANGING DIMENSIONS (SCD)
================================================================================

PROBLEM: When data changes (e.g., doctor changes specialty), should we:
- Overwrite the old value? (lose history)
- Keep both old and new? (preserve history)

2.1 SCD Type 1 (Overwrite) - Used for most dimensions
------------------------------------------------------
Simply update the record. History is lost but queries are simple.

Used for: dim_department, dim_diagnosis, dim_procedure

Example:
  Before: Dr. Smith | Internal Medicine
  After:  Dr. Smith | Cardiology  (old value gone)

2.2 SCD Type 2 (Track History) - Used for provider & patient
------------------------------------------------------------
Create NEW row for each change. Old rows preserved with end dates.

Used for: dim_provider, dim_patient

Example:
  Row 1: Dr. Smith | Internal Medicine | 2024-01-01 | 2026-01-24 | FALSE
  Row 2: Dr. Smith | Cardiology        | 2026-01-25 | 9999-12-31 | TRUE

Why this matters:
- January reports still show "Internal Medicine" (accurate!)
- Current reports show "Cardiology"
- Audit trail preserved (required for healthcare compliance)

2.3 SCD Type 2 Columns
----------------------
- effective_date: When this version became active
- end_date: When this version ended (9999-12-31 = still current)
- is_current: TRUE for the active record, FALSE for history


================================================================================
3. DIMENSION LOAD LOGIC
================================================================================

3.1 dim_date (One-Time Load)
----------------------------
Load all dates 2020-2030 during initial setup. Never changes.

3.2 dim_encounter_type (Static)
-------------------------------
Hardcoded: Outpatient, Inpatient, ER. Never changes.

3.3 dim_patient (SCD Type 2)
----------------------------
Source: OLTP.patients

Transformations:
- Calculate age from date_of_birth
- Derive age_group (0-17, 18-34, 35-54, 55-74, 75+)
- Derive gender_description (M→Male, F→Female)

SCD Type 2 Logic:
- NEW patient → INSERT with is_current=TRUE
- CHANGED patient → UPDATE old row (end_date=today, is_current=FALSE)
                  → INSERT new row (effective_date=today, is_current=TRUE)
- UNCHANGED → Skip (no action)

3.4 dim_provider (SCD Type 2)
-----------------------------
Source: OLTP.providers + specialties (joined)

Denormalizes specialty into provider record (avoids extra join in queries).

SCD Type 2 Logic: Same as patient
- Track specialty changes over time
- Historical reports show correct specialty at time of service

3.5 dim_department (SCD Type 1)
-------------------------------
Source: OLTP.departments
Simple upsert - update existing or insert new.

3.6 dim_diagnosis (SCD Type 1)
------------------------------
Source: OLTP.diagnoses
Derives category from ICD-10 code (I% = Circulatory, E% = Endocrine, etc.)

3.7 dim_procedure (SCD Type 1)
------------------------------
Source: OLTP.procedures  
Derives category from CPT code range.


================================================================================
4. FACT TABLE LOAD LOGIC
================================================================================

Source: OLTP.encounters + billing + counts from junction tables

4.1 Incremental Load
--------------------
Only load encounters where:
- created_at >= last_load_timestamp (new encounters), OR
- updated_at >= last_load_timestamp (modified encounters)

4.2 Dimension Key Lookups
-------------------------
For each encounter, look up surrogate keys:
- date_key → from encounter_date formatted as YYYYMMDD
- patient_key → from dim_patient WHERE patient_id = X AND is_current = TRUE
- provider_key → from dim_provider WHERE provider_id = X AND is_current = TRUE
- department_key → from dim_department WHERE department_id = X
- encounter_type_key → from dim_encounter_type WHERE name = X

IMPORTANT: For SCD Type 2 dimensions, always use is_current = TRUE
to get the latest version.

4.3 Pre-Aggregated Metrics
--------------------------
Calculate once during ETL, store in fact table:
- diagnosis_count = COUNT from encounter_diagnoses
- procedure_count = COUNT from encounter_procedures
- total_claim_amount = from billing table
- total_allowed_amount = from billing table
- length_of_stay_days = discharge_date - encounter_date

4.4 Late-Arriving Billing
-------------------------
Billing often arrives days after the encounter.

Solution:
1. Initial load: Insert encounter with billing = 0
2. Later runs: UPDATE fact with billing when it arrives

```sql
UPDATE fact_encounters 
SET total_claim_amount = b.claim_amount,
    total_allowed_amount = b.allowed_amount
FROM billing b
WHERE fact_encounters.encounter_id = b.encounter_id
  AND fact_encounters.total_claim_amount = 0
  AND b.updated_at >= @last_load_timestamp
```


================================================================================
5. BRIDGE TABLE LOAD LOGIC
================================================================================

Bridge tables connect many-to-many relationships using surrogate keys.

5.1 bridge_encounter_diagnosis
------------------------------
For each encounter_diagnosis record:
- Look up encounter_key from fact_encounters
- Look up diagnosis_key from dim_diagnosis
- Insert into bridge table

5.2 bridge_encounter_procedure
------------------------------
Same pattern - convert natural keys to surrogate keys.

Incremental: Only load for encounters added since last load.


================================================================================
6. REFRESH STRATEGY
================================================================================

6.1 Recommended: Daily Incremental (Production)
-----------------------------------------------
Schedule: 2:00 AM nightly

Process:
1. Read last_load_timestamp from etl_metadata
2. Load new/changed dimension records (SCD Type 2 for provider/patient)
3. Load new/changed encounters to fact table
4. Update late-arriving billing
5. Load bridge table records for new encounters
6. Update etl_metadata with new timestamp

Benefits:
- Fast (processes only changes)
- No downtime (tables stay online)
- Efficient resource usage

6.2 Alternative: Full Refresh (Development/Recovery)
----------------------------------------------------
When to use:
- Initial setup
- Monthly reconciliation
- After major data fixes

Process:
1. Truncate all star schema tables (except dim_date)
2. Reload all dimensions
3. Reload all facts
4. Reload all bridge tables


================================================================================
7. ETL EXECUTION ORDER
================================================================================

1. dim_date           ← One-time (already loaded)
2. dim_encounter_type ← Static (already loaded)
3. dim_patient        ← SCD Type 2
4. dim_provider       ← SCD Type 2
5. dim_department     ← SCD Type 1 (upsert)
6. dim_diagnosis      ← SCD Type 1 (upsert)
7. dim_procedure      ← SCD Type 1 (upsert)
8. fact_encounters    ← Incremental load
9. Update billing     ← Late-arriving facts
10. bridge_diagnosis  ← For new encounters only
11. bridge_procedure  ← For new encounters only
12. Update metadata   ← Save new timestamp


================================================================================
8. ERROR HANDLING
================================================================================

1. Missing dimension key → Log warning, skip record or use "Unknown" default
2. Duplicate records → Use UPSERT pattern (INSERT ON DUPLICATE KEY UPDATE)
3. Referential integrity → Always load dimensions BEFORE facts
4. Failed load → Rollback transaction, retry from last successful checkpoint


================================================================================
